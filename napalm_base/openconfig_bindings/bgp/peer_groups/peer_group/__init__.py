
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import config
import state
import timers
import transport
import error_handling
import logging_options
import ebgp_multihop
import route_reflector
import as_path_options
import add_paths
import afi_safis
import graceful_restart
import apply_policy
import use_multiple_paths
class peer_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp - based on the path /bgp/peer-groups/peer-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP peer-groups configured on the local system -
uniquely identified by peer-group name
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__peer_group_name','__config','__state','__timers','__transport','__error_handling','__logging_options','__ebgp_multihop','__route_reflector','__as_path_options','__add_paths','__afi_safis','__graceful_restart','__apply_policy','__use_multiple_paths',)

  _yang_name = 'peer-group'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    helper = kwargs.pop("path_helper", None)
    if helper is False:
      self._path_helper = False
    elif helper is not None and isinstance(helper, xpathhelper.YANGPathHelper):
      self._path_helper = helper
    elif hasattr(self, "_parent"):
      helper = getattr(self._parent, "_path_helper", False)
      self._path_helper = helper
    else:
      self._path_helper = False

    self._extmethods = False
    self.__route_reflector = YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__ebgp_multihop = YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__use_multiple_paths = YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__as_path_options = YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__peer_group_name = YANGDynClass(base=ReferenceType(referenced_path='../config/peer-group-name', caller=self._path() + ['peer-group-name'], path_helper=self._path_helper, require_instance=True), is_leaf=True, yang_name="peer-group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__apply_policy = YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__afi_safis = YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__add_paths = YANGDynClass(base=add_paths.add_paths, is_container='container', yang_name="add-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__logging_options = YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__error_handling = YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'bgp', u'peer-groups', u'peer-group']

  def _get_peer_group_name(self):
    """
    Getter method for peer_group_name, mapped from YANG variable /bgp/peer_groups/peer_group/peer_group_name (leafref)

    YANG Description: Reference to the name of the BGP peer-group used as a
key in the peer-group list
    """
    return self.__peer_group_name
      
  def _set_peer_group_name(self, v, load=False):
    """
    Setter method for peer_group_name, mapped from YANG variable /bgp/peer_groups/peer_group/peer_group_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_group_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_group_name() directly.

    YANG Description: Reference to the name of the BGP peer-group used as a
key in the peer-group list
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      t = YANGDynClass(v,base=ReferenceType(referenced_path='../config/peer-group-name', caller=self._path() + ['peer-group-name'], path_helper=self._path_helper, require_instance=True), is_leaf=True, yang_name="peer-group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_group_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=ReferenceType(referenced_path='../config/peer-group-name', caller=self._path() + ['peer-group-name'], path_helper=self._path_helper, require_instance=True), is_leaf=True, yang_name="peer-group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__peer_group_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_group_name(self):
    self.__peer_group_name = YANGDynClass(base=ReferenceType(referenced_path='../config/peer-group-name', caller=self._path() + ['peer-group-name'], path_helper=self._path_helper, require_instance=True), is_leaf=True, yang_name="peer-group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /bgp/peer_groups/peer_group/config (container)

    YANG Description: Configuration parameters relating to the BGP neighbor or
group
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /bgp/peer_groups/peer_group/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration parameters relating to the BGP neighbor or
group
    """
    try:
      t = YANGDynClass(v,base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /bgp/peer_groups/peer_group/state (container)

    YANG Description: State information relating to the BGP neighbor or group
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /bgp/peer_groups/peer_group/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State information relating to the BGP neighbor or group
    """
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_timers(self):
    """
    Getter method for timers, mapped from YANG variable /bgp/peer_groups/peer_group/timers (container)

    YANG Description: Timers related to a BGP neighbor or group
    """
    return self.__timers
      
  def _set_timers(self, v, load=False):
    """
    Setter method for timers, mapped from YANG variable /bgp/peer_groups/peer_group/timers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timers() directly.

    YANG Description: Timers related to a BGP neighbor or group
    """
    try:
      t = YANGDynClass(v,base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__timers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timers(self):
    self.__timers = YANGDynClass(base=timers.timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /bgp/peer_groups/peer_group/transport (container)

    YANG Description: Transport session parameters for the BGP neighbor or group
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /bgp/peer_groups/peer_group/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: Transport session parameters for the BGP neighbor or group
    """
    try:
      t = YANGDynClass(v,base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=transport.transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_error_handling(self):
    """
    Getter method for error_handling, mapped from YANG variable /bgp/peer_groups/peer_group/error_handling (container)

    YANG Description: Error handling parameters used for the BGP neighbor or
group
    """
    return self.__error_handling
      
  def _set_error_handling(self, v, load=False):
    """
    Setter method for error_handling, mapped from YANG variable /bgp/peer_groups/peer_group/error_handling (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_handling is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_handling() directly.

    YANG Description: Error handling parameters used for the BGP neighbor or
group
    """
    try:
      t = YANGDynClass(v,base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_handling must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__error_handling = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_handling(self):
    self.__error_handling = YANGDynClass(base=error_handling.error_handling, is_container='container', yang_name="error-handling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_logging_options(self):
    """
    Getter method for logging_options, mapped from YANG variable /bgp/peer_groups/peer_group/logging_options (container)

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    return self.__logging_options
      
  def _set_logging_options(self, v, load=False):
    """
    Setter method for logging_options, mapped from YANG variable /bgp/peer_groups/peer_group/logging_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logging_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logging_options() directly.

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    try:
      t = YANGDynClass(v,base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logging_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__logging_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logging_options(self):
    self.__logging_options = YANGDynClass(base=logging_options.logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_ebgp_multihop(self):
    """
    Getter method for ebgp_multihop, mapped from YANG variable /bgp/peer_groups/peer_group/ebgp_multihop (container)

    YANG Description: eBGP multi-hop parameters for the BGP neighbor or group
    """
    return self.__ebgp_multihop
      
  def _set_ebgp_multihop(self, v, load=False):
    """
    Setter method for ebgp_multihop, mapped from YANG variable /bgp/peer_groups/peer_group/ebgp_multihop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp_multihop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp_multihop() directly.

    YANG Description: eBGP multi-hop parameters for the BGP neighbor or group
    """
    try:
      t = YANGDynClass(v,base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp_multihop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__ebgp_multihop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp_multihop(self):
    self.__ebgp_multihop = YANGDynClass(base=ebgp_multihop.ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_route_reflector(self):
    """
    Getter method for route_reflector, mapped from YANG variable /bgp/peer_groups/peer_group/route_reflector (container)

    YANG Description: Route reflector parameters for the BGP neighbor or group
    """
    return self.__route_reflector
      
  def _set_route_reflector(self, v, load=False):
    """
    Setter method for route_reflector, mapped from YANG variable /bgp/peer_groups/peer_group/route_reflector (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_reflector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_reflector() directly.

    YANG Description: Route reflector parameters for the BGP neighbor or group
    """
    try:
      t = YANGDynClass(v,base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_reflector must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__route_reflector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_reflector(self):
    self.__route_reflector = YANGDynClass(base=route_reflector.route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_as_path_options(self):
    """
    Getter method for as_path_options, mapped from YANG variable /bgp/peer_groups/peer_group/as_path_options (container)

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    return self.__as_path_options
      
  def _set_as_path_options(self, v, load=False):
    """
    Setter method for as_path_options, mapped from YANG variable /bgp/peer_groups/peer_group/as_path_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_path_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_path_options() directly.

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    try:
      t = YANGDynClass(v,base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_path_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__as_path_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_path_options(self):
    self.__as_path_options = YANGDynClass(base=as_path_options.as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_add_paths(self):
    """
    Getter method for add_paths, mapped from YANG variable /bgp/peer_groups/peer_group/add_paths (container)

    YANG Description: Parameters relating to the advertisement and receipt of
multiple paths for a single NLRI (add-paths)
    """
    return self.__add_paths
      
  def _set_add_paths(self, v, load=False):
    """
    Setter method for add_paths, mapped from YANG variable /bgp/peer_groups/peer_group/add_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_add_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_add_paths() directly.

    YANG Description: Parameters relating to the advertisement and receipt of
multiple paths for a single NLRI (add-paths)
    """
    try:
      t = YANGDynClass(v,base=add_paths.add_paths, is_container='container', yang_name="add-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """add_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=add_paths.add_paths, is_container='container', yang_name="add-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__add_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_add_paths(self):
    self.__add_paths = YANGDynClass(base=add_paths.add_paths, is_container='container', yang_name="add-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_afi_safis(self):
    """
    Getter method for afi_safis, mapped from YANG variable /bgp/peer_groups/peer_group/afi_safis (container)

    YANG Description: Per-address-family configuration parameters associated with
the neighbor or group
    """
    return self.__afi_safis
      
  def _set_afi_safis(self, v, load=False):
    """
    Setter method for afi_safis, mapped from YANG variable /bgp/peer_groups/peer_group/afi_safis (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safis() directly.

    YANG Description: Per-address-family configuration parameters associated with
the neighbor or group
    """
    try:
      t = YANGDynClass(v,base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safis must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__afi_safis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safis(self):
    self.__afi_safis = YANGDynClass(base=afi_safis.afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_graceful_restart(self):
    """
    Getter method for graceful_restart, mapped from YANG variable /bgp/peer_groups/peer_group/graceful_restart (container)

    YANG Description: Parameters relating the graceful restart mechanism for BGP
    """
    return self.__graceful_restart
      
  def _set_graceful_restart(self, v, load=False):
    """
    Setter method for graceful_restart, mapped from YANG variable /bgp/peer_groups/peer_group/graceful_restart (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_graceful_restart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_graceful_restart() directly.

    YANG Description: Parameters relating the graceful restart mechanism for BGP
    """
    try:
      t = YANGDynClass(v,base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """graceful_restart must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__graceful_restart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_graceful_restart(self):
    self.__graceful_restart = YANGDynClass(base=graceful_restart.graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_apply_policy(self):
    """
    Getter method for apply_policy, mapped from YANG variable /bgp/peer_groups/peer_group/apply_policy (container)

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    return self.__apply_policy
      
  def _set_apply_policy(self, v, load=False):
    """
    Setter method for apply_policy, mapped from YANG variable /bgp/peer_groups/peer_group/apply_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apply_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apply_policy() directly.

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    try:
      t = YANGDynClass(v,base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apply_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__apply_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apply_policy(self):
    self.__apply_policy = YANGDynClass(base=apply_policy.apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)


  def _get_use_multiple_paths(self):
    """
    Getter method for use_multiple_paths, mapped from YANG variable /bgp/peer_groups/peer_group/use_multiple_paths (container)

    YANG Description: Parameters related to the use of multiple paths for the
same NLRI
    """
    return self.__use_multiple_paths
      
  def _set_use_multiple_paths(self, v, load=False):
    """
    Setter method for use_multiple_paths, mapped from YANG variable /bgp/peer_groups/peer_group/use_multiple_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_multiple_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_multiple_paths() directly.

    YANG Description: Parameters related to the use of multiple paths for the
same NLRI
    """
    try:
      t = YANGDynClass(v,base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_multiple_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)""",
        })

    self.__use_multiple_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_multiple_paths(self):
    self.__use_multiple_paths = YANGDynClass(base=use_multiple_paths.use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bgp', defining_module='openconfig-bgp', yang_type='container', is_config=True)

  peer_group_name = property(_get_peer_group_name, _set_peer_group_name)
  config = property(_get_config, _set_config)
  state = property(_get_state, _set_state)
  timers = property(_get_timers, _set_timers)
  transport = property(_get_transport, _set_transport)
  error_handling = property(_get_error_handling, _set_error_handling)
  logging_options = property(_get_logging_options, _set_logging_options)
  ebgp_multihop = property(_get_ebgp_multihop, _set_ebgp_multihop)
  route_reflector = property(_get_route_reflector, _set_route_reflector)
  as_path_options = property(_get_as_path_options, _set_as_path_options)
  add_paths = property(_get_add_paths, _set_add_paths)
  afi_safis = property(_get_afi_safis, _set_afi_safis)
  graceful_restart = property(_get_graceful_restart, _set_graceful_restart)
  apply_policy = property(_get_apply_policy, _set_apply_policy)
  use_multiple_paths = property(_get_use_multiple_paths, _set_use_multiple_paths)


  _pyangbind_elements = {'peer_group_name': peer_group_name, 'config': config, 'state': state, 'timers': timers, 'transport': transport, 'error_handling': error_handling, 'logging_options': logging_options, 'ebgp_multihop': ebgp_multihop, 'route_reflector': route_reflector, 'as_path_options': as_path_options, 'add_paths': add_paths, 'afi_safis': afi_safis, 'graceful_restart': graceful_restart, 'apply_policy': apply_policy, 'use_multiple_paths': use_multiple_paths, }


